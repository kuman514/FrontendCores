# JavaScript

## 원시값
- 문자열 (string)
- 숫자 (number)
- 불리언 (boolean)
- null
- undefined
- BigInt
- 심볼 (Symbol)

## var, let, const
- var
  - 함수 레벨(함수 내에서 선언되었을 경우) 또는 전역 스코프 변수.
  - 재선언 가능. (같은 식별자로 var 중복 선언 가능)
  - 재할당 가능. (= 연산자를 통한 값 갱신 가능)
  - 호이스팅 가능. (선언부 위에서 참조 가능)
- let
  - 블록 레벨 스코프 변수. 블록(중괄호({})로 감싸인 범위)을 벗어나면 참조할 수 없다.
  - 재선언 불가. (같은 식별자로 let 중복 선언 불가)
  - 재할당 가능. (= 연산자를 통한 값 갱신 가능)
  - 호이스팅 불가. (선언부 위에서 참조 불가)
- const
  - 블록 레벨 스코프 변수. 블록(중괄호({})로 감싸인 범위)을 벗어나면 참조할 수 없다.
  - 재선언 불가. (같은 식별자로 const 중복 선언 불가)
  - 재할당 불가. (= 연산자를 통한 값 갱신 불가)
  - 호이스팅 불가. (선언부 위에서 참조 불가)

## null, undefined, 선언되지 않은 변수
- null
- undefined
- 선언되지 않은 변수

## 이벤트 루프
- 콜 스택
- 태스크 큐

## 프로토타입
- 객체의 \_\_proto\_\_ 속성.

## 이벤트 버블링
- 어떤 엘리먼트에서 클릭이나 변경 등의 이벤트가 발생하였을 때, 해당 엘리먼트부터 시작해서 최상단 엘리먼트에 도달할 때까지 이벤트가 부모 엘리먼트로 전파되는 현상.
- 이를 멈추려면 (이벤트 객체).stopPropagation()을 호출한다.

## 이벤트 위임
- 이벤트 버블링의 특성을 활용하여, 자식 엘리먼트의 이벤트 핸들링을 부모 엘리먼트에 이관하는 방법을 말한다.
- 이벤트를 핸들링 해야할 자식 엘리먼트가 여러 개 있고 그 여러 핸들링이 서로 비슷할 때, 부모 엘리먼트에 이관하는 것이 이벤트 핸들링의 유지보수를 더욱 용이하게 할 수 있다.

## Function 객체
- Function()
- new Function()

## this가 정해지는 우선순위
1. new 객체 생성을 통해 생성되었는가?
2. .call, .bind, .apply의 thisArg 파라미터로 전달받았는가?
3. 객체의 멤버로써 존재하는가?
4. 일반적인 호출인가?
- 1번 ~ 4번 조건 중 여러 개를 충족한다면, 1번-2번-3번-4번 순서의 우선순위로 this가 결정된다.
- 화살표 함수는 이 조건을 모두 무시하고, 무조건 화살표 함수가 선언된 렉시컬 스코프가 this로 정해진다.

## IIFE (Immediately Invoked Function Expression)

## 고차함수 (또는 일급함수)
- 함수의 파라미터로 전달되는 함수.
- 또는 함수에서 리턴으로 받게 되는 함수.

## 클로저
- 어떤 함수의 리턴으로 받게 되는 일급함수 중, 그 함수 외부에서 접근할 수 없는, 함수 내 지역변수에 접근할 수 있게 해주는 통로 역할을 하는 일급함수.
- 예시: React의 useState

## 호이스팅
- 함수나 변수가 선언되기 전에 해당 함수나 변수에 접근할 수 있게 하는 JavaScript의 특성 중 하나.

## 스코프
- 함수나 변수에 접근할 수 있는 범위.
- 글로벌 스코프: 어디든지 해당 함수 또는 변수에 접근할 수 있다.
- 지역 스코프: 그 지역 내에서만 해당 함수 또는 변수에 접근할 수 있다.

### 렉시컬 스코프
- 함수나 변수가 선언된 곳의 직속 상위 스코프.

## 구조 분해 할당
- 배열이나 객체를 분해시켜 개별 변수에 할당시키는 방법.
- 예시: const [one, two, three] = [1, 2, 3] 또는 const { yasuo, maverick } = { yasuo: 1, maverick: '222' } 등등.

## spread 연산자와 rest 연산자의 차이
- spread 연산자: ...[...] 또는 ...{...} 연산자를 통해 배열이나 객체에 있는 원소들을 푸는 연산.
- rest 연산자: ...rest 등등의 연산자를 통해 = 연산자의 우항 또는 함수의 파라미터 등등에서 전달받은 나머지를 하나로 묶는 연산이다.

## AJAX (Asynchronus JavaScript And XML)
- JavaScript와 XML을 사용한 비동기적 정보 교환 기능. 
- AJAX의 장점
  - AJAX를 통해, 전체 페이지를 다시 불러오지 않고 페이지의 일부만 바꿈으로써 동적인 웹 페이지를 구현할 수 있다.
  - AJAX를 사용하면, 웹 페이지 일부의 로딩을 기다리지 않고 비동기적으로 페이지 내 다른 활동을 할 수 있다.
- AJAX를 어떻게 할 수 있나?
  - XMLHttpRequest 사용
  - fetch API 사용

## == 연산자와 === 연산자의 차이
- == (느슨한 등가) 연산자: 필요하다면 타입 변환을 하며 두 항의 값이 동일한지 비교하는 연산자이다.
  - 예: undefined == null은 true이며, 1 == '1'도 true이다.
- === (엄격한 등가) 연산자: 타입 변환 없이 strict하게 두 항의 값이 동일한지 비교하는 연산자이다.
  - 예: undefined === null은 false이며, 1 === '1'도 false이다.
- JavaScript에선 === 연산자의 사용이 권장된다.

## Same Origin Policy (동일 출처 정책)
- 통신으로 데이터를 주고받을 때 출처(Origin)이 동일해야 한다는 정책이다. 이를 어기면 CORS Error가 발생한다.
- 이 때, 출처(Origin)은 프로토콜+도메인명+포트번호를 말하는 것이다.
- 즉, `https://yasuomaverick.com:8080/koishi`인 출처는 `https://yasuomaverick.com:8080`과 데이터를 주고받을 수 있다는 뜻이다.

## CORS (Cross Origin Resource Sharing)
- 서로 다른 두 출처(Origin, 프로토콜+도메인명+포트번호)가 데이터를 주고받을 수 있도록 서버가 허락해주는 HTTP 헤더 기반 메커니즘이다.
- 다른 출처에게 요청하는 방법
  - 출처가 서버 측에서 반환한 Access-Control-Allow-Origin 헤더값에 해당
  - OPTIONS 메소드를 통해, 허용되는 출처나 메소드나 헤더 등등을 사전 조사

## 템플릿 리터럴
- \`...\`(백틱)으로 감싸여진, 문자열 사용에 큰 유연성을 더하는 기능으로, 문자열 삽입과 문자열 안에 변수 넣기 등등을 더욱 간단하게 할 수 있다.
- 백틱 내에 ${expression}(플레이스홀더)를 통해 expression 값을 템플릿에 넣어 문자열로 만들 수 있다.
- 예시: const what = 'science'일 경우, \`yasuo is ${what}\` === 'yasuo is science'가 된다.

## 함수

### function 키워드

### 화살표 함수

## 비동기 처리

### 콜백 활용

### Promise 객체 활용

### async/await 활용

## use strict

## 호스트 객체와 네이티브 객체의 차이

## JavaScript 개발에 쓰이는 디버깅 툴

## document.onload, DOMContentLoaded

## Polyfill

## 번들러

## 커리 (curry)

## SPA (Single Page Application)

## SEO (Search Engine Optimization)

## 제네레이터 함수

## 문자열 관련 함수

## 객체 관련 함수

## 배열 관련 함수

### call, bind, apply

### forEach, map

## Date 관련 함수

## JSON 관련 함수

## Promise 객체 관련 함수
